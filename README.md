# 자료구조 & 알고리즘
## 1. 완전 탐색
1. 15651번. N과 M (3)
   - 중복순열 : 중복을 허용해서 순서 있게 나열하기
2. 15649번. N과 M (1)
   - 순열 : 중복없이 순서 있게 나열하기
3. 155652번. N과 M (4)
   - 중복조합 : 중복을 허용해서 고르기
4. 15650번. N과 M (2)
   - 조합 : 중복없이 고르기
5. 14888번. 연산자 끼워넣기
6. 9663번. N-Queen

### 연습문제
1. 1182번. 부분수열의 합
2. 1795번. 암호 만들기
3. <span style="color:red">13663번. N과 M (9)</span>

## 2. 정렬
1. 특성
   1. 같은 정보들은 입접해 있다.
   2. 각 원소마다, 가장 가까운 원소는 자신의 양 옆 중에 있다.
   3. N개의 원소를 정렬하는 것은 O(NlogN)의 시간 복잡도를 가진다.
2. 기본 자료형 정렬 - Dual-Pivot Quick Sort : in-place
   - 정렬 과정에서 N에 비해 충분히 무시할만한 메모리만 추가로 사용한다. 
   - 1부터 N까지 사용한다면, 동등한 위상의 원소들의 순서관계를 보장하지 않으므로,
   - Arrays.sort(a, 1, N+1)을 이용해 정렬을 수행해야한다.
3. 객체 정렬 - Time Sort :stable
   - 동등한 위상의 원소들의 순서 관계가 보장된다.

### 기본 문제
1. 10825번. 국영수
2. <span style="color:red">1015번. 수열 정렬 </span>
3. 11652번. 카드
4. 15970번. 화살표 그리기

### 연습문제
1. 1181번. 단어 정렬
   ```java
       static void pro() {
        Arrays.sort(a, new MyComparator());
        for (int i = 0; i < N; i++) {
            if (i == 0 || a[i].compareTo(a[i - 1]) != 0)
                sb.append(a[i]).append('\n');
        }
        System.out.println(sb.toString());
    }
   ```
   ```java
       static void pro() {
       // 정렬 조건에 맞게 단어를 정렬하기
       Arrays.sort(a, (o1, o2)-> o1.length()!=o2.length()?o1.length()-o2.length():o1.compareTo(o2));

        // 출력하기
        String s="";
        for (String str: a) {
            if(!s.equals(str)) {
                sb.append(str).append('\n');
                s=str;
            }
        }
        System.out.println(sb);
    }
   ```
2. 20291번. 파일 정리
   - TreeMap 이용
   ```java
    static TreeMap<String, Integer> map=new TreeMap<>((o1,o2)-> o1.compareTo(o2));

    static void input() {
        N = scan.nextInt();
        a = new String[N + 1];
        for (int i = 1; i <= N; i++) {
            // 입력된 파일 이름을 . 을 기준으로 나눠서 확장자를 가져오기
            String t=scan.next();
            String[] tmp=t.split("\\.");
            map.put(tmp[1], map.getOrDefault(tmp[1], 0)+1);
        }
    }

    static void pro() {
        // TODO: 확장자마다 몇 번 나타났나 count 하기
        for(String str:map.keySet()){
            sb.append(str).append(" ").append(map.get(str)).append("\n");
        }
        System.out.println(sb);
    }
   ```
   - 배열 이용하는 경우 : j가 N까지 돌고, 같은게 없으면 i가 j부터 시작. 따라서, i는 증가하지 않는다.
   ```java
       static void pro() {
        // TODO: 확장자마다 몇 번 나타났나 count 하기
        //1. 정렬 -> 문자의 오름차순 정렬(사전순)
        Arrays.sort(a, 1, N+1);
        //2. 정렬했을때 같으면 카운트 -> i를 증가시키지 않는다. 왜냐하면 다를 때는 j부터 시작해야하므로
        for(int i=1;i<=N;){
            int cnt=1;
            int j=i+1;

            //3. i를 기준으로 같은 경우가 있는지 j로 탐색해서 카운트
            for(;j<=N;j++) {
                //사전순이므로 같은경우엔 모두 붙어있다. -> 다르면 break;
                if (a[j].compareTo(a[i]) == 0) cnt++;
                else break;
            }
            sb.append(a[i]).append(' ').append(cnt).append('\n');

            // 4. a[j] 가 a[i]랑 다를 때는, 다음 i가 j 부터 시작한다.
            i = j;
        }
        System.out.println(sb);
    }
   ```

## 3. 이분 탐색
### 정렬이 되어있지 않은 수열과 탐색 대상 X가 갖는 질문 - O(N)
1. X가 존재하는가
2. X[이하, 이상, 초과]의 원소는 몇개가 있는가
3. X랑 가장 가까운 원소는 무엇인가

### 정렬이 되어 있는 수열과 탐색 대상 X가 갖는 질문 - O(logN)
- 이분 탐색으로 같은 질문을 더 빠르게 해결할 수 있다.

### 이분 탐색 구현을 위한 변수
1. L := 탐색할 가치가 있는 범위의 왼쪽 끝 인덱스
2. R := 탐색할 가치가 있는 범위의 오른쪽 끝 인덱스
3. Result := 탐색한 X의 위치
4. 탐색 목표 := X이하의 원소 중에 가장 오른쪽에 있는 원소
   - L=1, R=9, M=(L+R)/2=5 -> A[M]과 X를 비교
   - L<=R이면 계속 반복, 즉 L>R이면 종료
   - A[M]<X -> L = M+1=6, R=9
   - A[M]>=X -> L=1, R = M-1=4;
   - N이 10만일 때, 10만과 16으로 시간 복잡도의 엄청난 차이가 존재하게 된다.

### 이분 탐색 주의 할점
1. 정렬하지 않는 경우
2. L, R, M, Result를 사용해 부등호를 잘못 사용하는 경우
3. L, R의 범위를 잘못 설정하거나, Result의 초기값을 잘못 설정하는 경우

### 기본 문제
1. 7795번. 먹을 것인가 먹힐 것인가
2. 2470번. 두 용액

### 연습 문제
1. 1920번. 수 찾기
2. 1764번. 듣보잡
3. 3273번. 두 수의 합
4. 10816번. 숫자 카드 2


### 이분 탐색의 아이디어 - 매개변수 탐색
1. 매개변수를 만들기
2. 만든 매개변수로 문제에 해당하는 YES/NO 조건 만들 수 있는가?
3. <span style="color:red">정렬된 상태인지 확인하고 정렬이 필요하면 정렬한다. </span>
4. 바꾼 문제가 더 풀기 쉬우면, 매개변수 탐색 수행해서 해결
   - 정렬하고, 매개변수를 정렬했으니까 왼쪽부터 차례대로 결정하고, 이분탐색한다.
   - O(NlogN), O(N), O(logX) = O(NlogN+NlogX)

### 기본 문제와 해당하는 연습 문제
1. 2805번. 나무 자르기
   1. 1654번. 랜선 자르기
   2. 2512번. 예산
2. 2110번. 공유기 설치
   1. 2343번. 기타 레슨
   2. 6236번. 용돈 관리
   3. 13702번. 이상한 술집 
   4. 17266번. 어두운 굴다리

   
### 연습문제 (Hard)          
1. 1300번. K번째 수
2. 1637번. 날카로운 눈

## 4. 두 포인터
1. 정답을 찾기 위해 찾는 영역(or 과정)을 줄일 수 없을까?
2. 필요한 부분만 (or 빠르게) 탐색
3. 정답을 찾기 위해 탐색해야하는 영역을 줄여서 꼭 필요한 부분만 탐색하도록 하자.

### 투 포인터
- 화살표 두 개에 의미를 부여해서 탐색 범위를 압축한다.
  1. 1차원 배열 위에 2개의 포인터를 만드는 경우
     1. 2개의 포인터가 모두 왼쪽에서 시작해서 **같은 방향**으로 이동
     2. 2개의 포인터가 양 끝에서 **서로를 향해** 이동
  2. 배열로 주어지진 않지만, 관찰을 통해 등장하는 **변수 2개의 값**을 투 포인터로 표현하는 경우

- 투 포인터 키워드
  1. 1차원 배열에서의 "연속 부분 수열" or "순서를 지키며 차례대로"
     - 배열을 모두 보는 게 아니라, 필요한 부분만 압축해서 탐색한다.
  2. 곱의 최소
     - A*B의 최소화를 하기 위해서는, A 커지면, B는 작아져야한다.

- 접근하기
  1. 왼쪽 시작 L을 결정 : O(N)
  2. 오른쪽 끝 R을 L부터 시작해서 이동 : O(N)
  3. O(N^2)
- 넣었다가 뺐다가 -> **++R, R+1, R++**
  1. 왼쪽 시작 L을 결정 : O(N)
  2. 한번만 오른쪽 끝 R을 L부터 시작해서 이동
  3. 커지면 맨 앞부터 빼면서, 작거나 같으면 다음 값부터 추가하면서 탐색한다.

```java
while(R+1<=n&&sum<S){
    R++;
    sum+=a[R];
}

while(R+1<=n&&sum<S){
   sum+=a[++R];
}
```
### 응용 문제 (1) : 두 용액 
#### 이분 탐색을 투포인터로
1. L := "남아 있는 것들 중" 제일 작은 원소
2. R := "남아 있는 것들 중" 제일 큰 원소
#### 현재 남아있는 최솟값+최댓값을 계산을 반복한다.
- 숫자가 하나만 남으면 종료
  1. 최소+최대 <0 -> 최소 입장에서는 최선이므로, 최소를 삭제
  2. 최소+최대 >0 -> 최대 입장에서는 최선이므로, 최대를 삭제
  3. 최소+최대=0 -> 정답이므로 출력
#### 접근법
   1. 매 순간 L,R을 찾는다 -> O(N)
   2. 원소가 1개가 될때까지 반복 -> N번 반복
   3. O(N^2)
#### 정렬과 투포인터로 최솟값과 최댓값을 빠르게 찾는다.
- 정렬된 상태이면, 항상 왼쪽이 최솟값 오른쪽이 최댓값이므로 
- L=R이 되면 서로 다른 용액을 못찾으므로 종료
#### 투포인터를 이용했을 때의 시간 복잡도
1. 정렬 -> O(NlogN)
2. 매순간, L,R로 계산해서 이동시킨다. -> O(N)
3. O(NlogN)

### 응용 문제 (2) : List of Number Unique Numbers
#### 수열에서 연속한 1개 이상의 수를 뽑았을 때 같은 수가 여러 번 등장하지 않은 경우의 수
1. 정답의 최대치 : N이 10만이면 모든 연속 구간이 카운트 ->N+(N-1)...= 50억
   - 따라서 long 타입 사용해야한다.
2. 접근법 (1)
   1. 왼쪽 시작 L 결정 : O(N)
   2. 오른쪽 끝 R을 L부터 시작해서 이동 : O(N)
   3. R을 이동해서 추가된 원소가 [L, R-1] 안에 있는지 확인 : O(N)
      - O(N^3)으로 시간 복잡도를 낮추는 방법 모색해야함
      - 투 포인터를 이용해 꼭 필요한 부분만 탐색하기
3. 접근법 (2)
   1. 왼쪽 시작 L 결정 : O(N)
   2. 오른쪽 끝 R을 L부터 시작해서 이동 : O(N)
   3. 숫자마다 [L, R]안에 몇 개나 있는지 직접 센다.
      - 각 원소가 1부터 10만 사이이므로, 해당 값을 카운팅하는 배열을 만든다.
      - 상수 시간으로 처리가능 : O(1)
   4. O(N^2) -> N이 10만이므로 시간초과
4. 접근법 (3)
   - 1~3까지 중복된게 없다면, 2~3까지도 당연히 중복된게 없다.
     1. R을 이동 가능한 끝까지 이동시키면서 카운팅
     2. 개수를 센다.
     3. L-1을 카운팅에서 제외한다.
   - 정리
     1. 왼쪽 시작 L의 이동 횟수 N번
     2. 오른쪽 끝 R을 이전 R부터 시작해서 이동
     3. L,R이 각자 최대 N번 이동한다. : O(N)
   - 결론
     1. 왼쪽 시작 L 결정 : O(N)
     2. 오른쪽 끝 R을 이전의 R부터 시작해서 이동
     3. R을 이동해서 추가된 원소가 [L, R-1] 안에 있는지 확인 : O(1)
     - O(N) 

### 응용 문제 (3) : 좋다
1. 접근법
   1. 타겟 수 결정 : O(N)
   2. 다른 수 2개 결정해서 만들어지나 확인 : O(N^2)
   3. O(N^3)
2. 투 포인터 적용
   1. 정렬 수행 : O(NlogN)
   2. 타겟 수 결정 : O(N)
   3. 다른 수 2개 결정해서 만들어지나 확인 : O(N)
      - 타겟 숫자와 가까운걸 찾는다.
      - O(N^2)

### 응용 문제 (4) : 고냥이
- 최대 N개의 종류의 알파벳을 가진 연속된 문자열만 인식
- 인식할 수 있는 최대 문자열의 길이? = kind
- 즉, while(kind>N) 반복해서 L을 이동시키면서 조건을 성립하는 최대 문자열의 길이를 찾는다.
- kind를 계산하는 방법
  1. for문으로 돌면서 kind를 O(26)으로 계산하는 방법
  2. kind를 O(1)으로 계산하는 방법
     - 기준 : kind가 바뀌는 기점은 cnt라는 배열에 변화가 발생할 때 
     - 접근 : add, erase 메서드 호출시 cnt라는 배열이 변화한다. 
     - 구현 : add와 erase 메서드 호출했을 때, 
       1. add의 경우, 파라미터에 해당하는 배열 값이 1이 될 때 -> 0에서 1로 변화했을때 kind++ 
       2. erase의 경우, 파라미터에 해당하는 배열 값이 0이 될 때 -> 1에서 0으로 변화했을때 kind--;

## 기본 문제
1. <span style='color:red'> 1806번. 부분합</span>
2. 2470번. 두 용액

## 연습 문제
1. 3273번. 두 수의 합

## 응용 문제
1. 13144번. List of Unique Numbers
2. 1253번. 좋다
   - 2473번. 세 용액
3. 16472번. 고냥이

### 연습 문제
1. 2003번. 수들의 합 2
2. 2559번. 수열
3. 15565번. 귀여운 라이언
4. 11728번. 배열 합치기
5. 2230번. 수 고르기


## 5. 그래프 탐색 (DFS & BFS)
### 인프런
#### 기초 (재귀함수, 트리, 그래프)
 1. 재귀함수 (스택프레임)
 2. 이진수 출력 (재귀 함수)
 3. 팩토리얼
 4. 피보나치 재귀 (메모이제이션)
 5. 이진트리 순회 (DFS)
 6. 부분집합 구하기 (DFS)
 7. 이진트리 레벨탐색 (BFS)
 8. 송아지 찾기1 (BFS)
 9. Tree의 말단 노드까지 가장 짧은 경로 (DFS)
 10. Tree의 말단 노드까지 가장 짧은 경로 (BFS)
 11. 그래프와 인접 행렬
 12. 경로탐색 (DFS)
 13. 경로탐색 (인접리스트)
 14. 그래프 최단 거리 (BFS)
#### 심화


### 백준
1. 기본 구현
   - 1260번. DFS와 BFS
2. 격자형 그래프
   - 2667번. 단지번호 붙이기
   - 1012번. 유기농 배추
   - 11724번. 연결 요소의 개수
   - 4963번. 섬의 개수
   - 3184번. 양
3. 일반 그래프
   - 2606번. 바이러스
   - 11403번. 경로 찾기
   - <span style="color:red"> 11725번. 트리의 부모 찾기 </span>
   - <span style="color:red"> 13023번. N명의 친구 </span>
4. 그래프로 만들기
   - 2251번. 물통
   - 1697번. 숨바꼭질
   - <span style="color:red"> 1389번. 케빈 베이컨의 6단계 법칙 </span>
   - <span style="color:red"> 5567번. 결혼식 
5. 멀터 소스 BFS (시작점이 여러개인 BFS)
   - 14502번. 연구소
   
6. 최소 이동 거리 BFS
   - 2178번. 미로 탐색
   - 7562번. 나이트의 이동
   - 2644번. 촌수 계산
   - 18404번. 현명한 나이트
7. 더블 BFS
   - 3055번. 탈출 (멀티소스 BFS이기도 함)
   - <span style="color:red"> 7569번. 토마토</span>

## 6. 트리
### 키워드
1. 두 정점 사이의 경로가 존재하고, 사이클이 존재하지 않는 경우만 고려한다.
2. 정점과 정점 사이를 잇는 N-1개의 간선이 존재하며, 모든 정점은 연결되어 있다.
3. 정점들이 모두 연결되어 있고, 사이클이 없는 그래프, 정점의 개수는 N이고 간선의 개수는 N-1개

### 아래의 특성 중 2개 이상 만족할 경우 트리
1. 모두가 연결되어 있어서 어떤 두점을 골라도 간선을 타고 서로 이동 가능
2. 사이클이 존재하지 않음
3. 정점 개수 |V| = 간선 개수 |E|+1

### 트리와 루트 트리
1. 트리에는 루트가 존재하는 경우와 루트가 존재하지 않는 경우가 존재
2. 트리가 존재하는 경우, 트리의 깊이를 기준으로 루트로부터의 거리에 대한 조건을 참고해 문제를 푼다.
3. 루트트리에는 조상, 자식, 형제, 말단 노드가 존재한다.
4. 일반적인 알고리즘 문제에서는 루트 트리를 이용한다. 
5. |V|=|E|+1이므로, 인접행렬로 만든다면 |V|의 제곱으로 공간복잡도 낭비

### 백준
1. 구현 (루트가 없는 트리에서 루트 만들기)
   - 11725번. 트리의 부모 찾기
   - <span style="color:red"> 4803번. 트리</span>
2. DFS를 이용하는 동적계획법
   - 1068번. 트리 (단말 노드의 개수(BFS/DFS)로도 가능)
   - 15681번. 트리와 쿼리
   - 14267번. 회사 문화1
3. BFS
   - 1991번. 트리 순회
   - 5639번. 이진 검색 트리
   - 9489번. 사촌
   - 20364번. 부동산 다툼
4. LCA (최소 공통 조상) 
   - 3584번. 가장 가까운 공통 조상
   - 1240번. 노드 사이의 거리
5. 최소신장트리 (크루스칼 알고리즘)
   - 15900번. 나무 탈출 (BFS도 가능)


## 위상 정렬
- Directed Acyclic Graph (DAG)
1. 방향성이 있는 Cyclic이 없고,정점(V) + 간선(E)으로 이루어진 그래프
2. 차수
   - 방향성이 있는 그래프에서의 차수
   - Indegree / Outdegree
   - 해당 정점이 도착지가 되는 간선의 개수, 해당 정점에서 나가는 간선의 개수
- DAG에서만 가능한 위상 정렬
1. 정점들을 위상에 맞게 정렬한다.
2. 위상이란 간선의 방향성을 조건으로 삼아서 방향성을 기준으로 정렬을 수행한다.
3. 즉, 정점들의 번호를 수열로 만들어 정렬을 한다.
4. 정렬 조건
   1. 출발지 -> 도착지가 존재한다면, 출발지가 도착지보다 먼저 나타나야함
   2. 즉, 간선 하나하나마다 어떤 정점이 다른 정점보다 먼저 나타나야 한다는 조건이 필요하다.
   3. 모든 정점들이 조건을 만족하면, 위상 정렬 가능
   4. 사이클이 존재하다면 어떻게 해도 해당 조건을 만족하지 않는다. -> 위상 정렬 불가능

### 접근법
1. 제일 먼저 올 수 있는 정점이 뭘까
  - 들어오는 간선이 없는 정점
2. 제일 먼저 올 수 있는 정점들의 후보들을 담아둔다.
3. 후보들을 이용해서 정렬 시작
   - 해당 정점은 그래프에서 삭제
   - 해당 정점과 관련된 간선도 함께 삭제
   - 그 상태에서 가장 먼저 올 수 있는 정점을 찾는다.
4. 하나씩 정렬시키면서 그래프에서 삭제하는 작업 반복

### 구현
1. 정점들의 Indegree인, Indeg[1...N] 계산 -> O(|E|) (간선 수만큼)
2. 들어오는 간선이 0인, 즉 Indege[i]==0인 정점들을 찾아서 자료구조 Queue에 담는다. -> O(|V|) (정점 수만큼)
   - 원소를 추가하기
   - 원소를 꺼내기
3. D가 빌 때까지 반복 
   1. D에서 원소 X를 꺼내서 정렬
   2. Graph에서 정점 X 제거 (연관된 간선도 제거)
   3. **새롭게 정렬 가능한 점을 찾아서 D에 추가**
      1. for문을 돌면서 모두 확인 -> O(|V|^2) (while, for, for : 정점 개수만큼 반복하는데, 간선의 개수만큼 반복 그 때마다 모든 정점을 확인)
      2. 정점 X 제거할 때, 즉 변경이 발생할 때만 indeg[y]==0이 될 수 있으므로 그때만 확인 -> O(|E|) (간선 개수만큼만 반복)

```java
while(!queue.isEmpty()){
    int x = queue.poll();
    sb.append(x).append(' ');
    for(int y : adj[x]){
        indeg[y]--;
    }
    for(int i = 1; i <= N; i++){
        if(i가 새롭게 indeg[i]==0 이라면) queue.add(i);
    }
}
```

```java
while(!queue.isEmpty()){
    int x = queue.poll();
    sb.append(x).append(' ');
    for(int y : adj[x]){
        indeg[y]--;
        if (indeg[y] == 0) queue.add(y);
    }
}
```
#### 기본 문제
1. 2252번. 줄 세우기
2. 1005번. ACM Craft

#### 기본 문제 (1) - 줄 세우기
1. 학생들의 키 관계가 주어진다.
2. 관계 -> 그래프 -> 정렬 -> 위상 정렬
3. 위상 정렬을 위해 그래프를 만든다.

#### 그래프 만들기 - 인접 리스트 O(V+E)
   - 정점 (V) := i번 학생
   - 간선 (E) := x번 학생이 y번 학생보다 먼저 서야한다. (x번 학생 키가 y번 학생 키보다 작다.)
1. x->y로 그래프를 만든다.
2. y로 들어가는 Indegree 배열값을 증가시킨다.
3. 차수가 0이 아닌 정점들을 Deque에 넣는다.
4. Deque가 빌 때까지 반복
   1. 뺀 정점을 정렬 결과에 추가
   2. 해당 정렬의 리스트 (=해당 정점이 시작점으로 하는 도착점들의 자료구조)에서 차수를 줄인다. (간선을 제거한다.)
   3. 새롭게 차수가 0이 된 정점들을 큐에 추가한다.

#### 연습 문제 (1)
1. 2623번. 음악 프로그램
2. 9470번. Strahler 순서
3. 14767번. 영우는 사기꾼?

#### 기본 문제 (2) - ACM Craft
1. 건물, 건설 규칙, 건설 시간
   - 건설해야하는 건물 4개
   - 각 건물마다 건설 시간이 다르다.
   - 건물마다의 건설 규칙이 존재
     - 선행되어야하는 조건이 존재
     - 먼저 다른 건물이 지어져야 건설 가능
2. 따라서 여러 건물들이 동시에 건설이 가능
3. 모든 건물들이 지어질 때까지 걸리는 최소 시간 =  max(T_done[X의 선행작업]) + T[X]
4. 위상정렬 순서로 T_done을 계산해나가야한다.
5. 테스트케이스가 여러개인 문제인 경우 -> 배열 초기화에 유의해야한다.
6. 위상 정렬상 앞에 오는 경우 -> 해당 건물의 건설 속도 = 해당 건물의 건설에 걸리는 시간
7. X -> Y의 간선을 지을 때,  Y에 X를 건설하는 데 걸리는 시간 추가해야한다. : max(T_done[Y의 선행작업], T_done[X의 선행작업]+T[Y])

![img.png](img.png)

#### 연습 문제 (2)
1. 1516번. 게임 개발
2. 2056번. 작업
3. 2637번. 장난감 조립


## 최단 경로 / 최단 거리 (Shortest Path)

| 이름             | 간선의 가중치 | 시작점   | 도착점   | 시간복잡도    |
|----------------|---------|-------|-------|----------|
| BFS            | 모두 1    | 한 정점  | 모든 정점 | O(V+E)   |
| Dijkstra       | \>=0    | 한 정점  | 모든 정점 | O(ElogV) |
| Floyd-Warshall | 제약 없음   | **모든 정점** | 모든 정점 | O(V^3)   |
| Bellman-Ford   | 제약 없음   | 한 정점  | 모든 정점 | O(V*E)   |
| SPFA           | 제약 없음   | 한 정점  | 모든 정점 | O(V*E)   |
| A*             | \>=0    | 한 정점  | **한 정점**  | O(b^d)   |
1. 그래프의 시작점에서 다른 지점까지의 최단 거리
2. BFS와 다익스트라 알고리즘이 자주 사용된다.
   1. 간선의 가중치가 존재하지 않을 때만 사용가능한 BFS
   2. 간선의 가중치와 관계없이 사용가능하지만 시간 복잡도가 높은 다익스트라 알고리즘

### 그래프 탐색 방법 중 하나인 BFS
1. 시작점에서 간선을 0개 이상 사용해서 갈 수 있는 정점들은 무엇인가 - DFS / BFS
2. 다른 정점까지 최소 이동 횟수를 계산 할 수 있는 BFS - 이동 횟수의 합이 최소 이동 횟수로 간선의 가중치는 1

### 양수인 간선의 가중치를 이용해서 최단 경로를 계산할 수 있는 **다익스트라 알고리즘**
1. 멀티 소스 BFS와 같이 멀티 소스 다익스트라도 가능
2. 다익스트라 알고리즘 한번에 시작점에서 모든 점까지의 최단 경로의 거리를 구할 수 있다.
3. 도착점과 관계없이 시작점만 주어진다면, 모든 점까지의 최단 거리를 구한다.
4. 정점에 대해서 단 한번만 방문한다.
4. O(ElogV)

### 다익스트라 알고리즘을 사용하기 위한 조건
1. dist[i] := 시작점에서 i번 정점까지 가능한 최단 거리
2. 자료구조 D := {(v,d) | 시작점에서 v까지 d만에 갈 수 있다는 정보를 담은 자료구조|


### 다익스트라 알고리즘의 슈도 코드
1. 변수 초기화와 자료구조 초기화 및 자료구조에 넣을 데이터 정의
   - dist[i] 초기화 : i까지의 가는 최단 경로 / 최단 거리 배열
     1. 시작점에서 시작점까지 거리는 0
     2. 시작점에서 다른 점까지의 거리는 모두 최댓값
     3. 자료구조 D에 시작점 정보를 추가 (S,0)
2. 자료구조 D 빌 때까지 반복
   1. D에서 가장 작은 d (v,d)를 꺼낸다.
   2. **뽑은 d의 가치 정보 확인**
      - dist[v] < d인지 확인하는 작업
      - v까지의 최단 거리보다 d가 크다면, 이미 가치가 없는 정보
      - 더 오래 걸리는 경로로, 폐기한다.
   3. 뽑은 d의 정보로, 새로운 정보를 D에 추가
      - d와 연결된 간선 정보를 자료구조에 추가
      - if( d+c < dist[w]) dist[w] = d+c
      - 자료구조 D에 (w, d+c)를 추가
      - 즉, 같은 경로를 더 짧은 거리로 갈 수 있는 거리로 갱신
        - **w까지가는 경로 dist[w]를 더 짧은 경로로 갱신하는 작업**
### 시간 복잡도
1. v,d를 통해 새로운 정보를 D에 추가하는 시간  : T*N 
2. D에서 mid(v,d) 추출하는데 걸리는 시간    :  T*N
3. T = T1*N1 + T2*N2

### 시간 복잡도 계산
1. N2 : D에서 원소가 추출되는 횟수, N1: D에 원소가 추가된 횟수
2. N2<= N1 : 추출된 횟수는 추가된 횟수보다 같거나 작을 수 밖에 없다.
3. T <= [T2+T1]*N2
   - N2 := deg(1) + deg(2)+ ... + deg(V) = |E| (간선의 개수)
      - 정점을 확인할 때마다 새로운 간선을 추가
      - 다익스트라의 특징은 모든 정점을 **최대 한 번씩**만 가치가 있는 v로 등장한다.
      - 모든 정점의 차수의 합은 간선의 개수와 같다.
4. T<= [T2+T1]*E
   - 자료구조에 원소를 빼는 시간, 자료구조에 원소를 추가하는 시간
   - 배열 : O(N), O(1)
   - 최소힙 / 우선순위 큐 : O(logE), O(logE) 
5. T <= O(ElogE) - 간선의 개수는 정점 개수의 제곱보다 갖거나 같다.
6. T = O(ElogV)

### 간선의 가중치가 음수가 되면 안되는 이유
1. 시간 복잡도가 보장되지 않기 때문에
2. (v,d)를 가치있는 경로만 구해야하지만, 음수인 경우 한 정점이 v로 추출되는 횟수가 1번으로 보장되지 않는다.
3. 즉, N(2) >> |E|      
   - 다익스트라의 모든 정점을 **최대 한 번씩**만 가치가 있는 v로 등장한다는 특징에 위배된다.

### 구현
- Info 클래스 : int idx, int dis
- 최소힙 PriortyQueue<Info> 
1. dist 배열 초기화, (S,0)을 D에 저장
   - dist배열을 무한대로 초기화
   - Info 클래스를 제네릭으로 하는 최소힙 생성하는데, 거리를 기준으로 오름차순
2. 초기값 설정
   - 시작점 정보를 최소힙에 추가
   - 거리 배열에 시작점을 0으로 갱신
3. 자료구조가 빌 때까지 반복
   - 최소 힙에서 꺼낸 정보의 가치 판단 (해당 정점의 거리가 최단 경로 배열보다 짧거나 같은지 확인)
   - 가치가 있는 정보면, 해당 정점에서의 모든 간선들이 최단 경로가 되는지 체크하고 큐에 추가
     1. for(Edge e : edges[info.idx]) 해당 정점의 간선 배열을 돌면서 간선 정보를 추가한다.
     2. if(dist[info.idx] + e.weight >= dist[e.to]) : 해당 정점에서의 간선정보들이 최단 경로가 되는지 체크
     3. dist[e.to] = dist[info.idx] + e.weight : e.to까지 갈 수 있는최단 경로 갱신한다. (해당 정점까지의 최단 경로 + 해당 간선의 가중치)
     4. pq.offer(new Info(e.to, dist[e.to])) : 정보를 갱신했으므로, 우선순위큐에 기록

![img_2.png](img_2.png)

#### 기본 문제
1. 1916번. 최소비용 구하기
2. 1753번. 최단경로