# 자료구조 & 알고리즘
## 1. 완전 탐색
1. 15651번. N과 M (3)
   - 중복순열 : 중복을 허용해서 순서 있게 나열하기
2. 15649번. N과 M (1)
   - 순열 : 중복없이 순서 있게 나열하기
3. 155652번. N과 M (4)
   - 중복조합 : 중복을 허용해서 고르기
4. 15650번. N과 M (2)
   - 조합 : 중복없이 고르기
5. 14888번. 연산자 끼워넣기
6. 9663번. N-Queen

### 연습문제
1. 1182번. 부분수열의 합
2. 1795번. 암호 만들기
3. <span style="color:red">13663번. N과 M (9)</span>

## 2. 정렬
1. 특성
   1. 같은 정보들은 입접해 있다.
   2. 각 원소마다, 가장 가까운 원소는 자신의 양 옆 중에 있다.
   3. N개의 원소를 정렬하는 것은 O(NlogN)의 시간 복잡도를 가진다.
2. 기본 자료형 정렬 - Dual-Pivot Quick Sort : in-place
   - 정렬 과정에서 N에 비해 충분히 무시할만한 메모리만 추가로 사용한다. 
   - 1부터 N까지 사용한다면, 동등한 위상의 원소들의 순서관계를 보장하지 않으므로,
   - Arrays.sort(a, 1, N+1)을 이용해 정렬을 수행해야한다.
3. 객체 정렬 - Time Sort :stable
   - 동등한 위상의 원소들의 순서 관계가 보장된다.

### 기본 문제
1. 10825번. 국영수
2. <span style="color:red">1015번. 수열 정렬 </span>
3. 11652번. 카드
4. 15970번. 화살표 그리기

### 연습문제
1. 1181번. 단어 정렬
   ```java
       static void pro() {
        Arrays.sort(a, new MyComparator());
        for (int i = 0; i < N; i++) {
            if (i == 0 || a[i].compareTo(a[i - 1]) != 0)
                sb.append(a[i]).append('\n');
        }
        System.out.println(sb.toString());
    }
   ```
   ```java
       static void pro() {
       // 정렬 조건에 맞게 단어를 정렬하기
       Arrays.sort(a, (o1, o2)-> o1.length()!=o2.length()?o1.length()-o2.length():o1.compareTo(o2));

        // 출력하기
        String s="";
        for (String str: a) {
            if(!s.equals(str)) {
                sb.append(str).append('\n');
                s=str;
            }
        }
        System.out.println(sb);
    }
   ```
2. 20291번. 파일 정리
   - TreeMap 이용
   ```java
    static TreeMap<String, Integer> map=new TreeMap<>((o1,o2)-> o1.compareTo(o2));

    static void input() {
        N = scan.nextInt();
        a = new String[N + 1];
        for (int i = 1; i <= N; i++) {
            // 입력된 파일 이름을 . 을 기준으로 나눠서 확장자를 가져오기
            String t=scan.next();
            String[] tmp=t.split("\\.");
            map.put(tmp[1], map.getOrDefault(tmp[1], 0)+1);
        }
    }

    static void pro() {
        // TODO: 확장자마다 몇 번 나타났나 count 하기
        for(String str:map.keySet()){
            sb.append(str).append(" ").append(map.get(str)).append("\n");
        }
        System.out.println(sb);
    }
   ```
   - 배열 이용하는 경우 : j가 N까지 돌고, 같은게 없으면 i가 j부터 시작. 따라서, i는 증가하지 않는다.
   ```java
       static void pro() {
        // TODO: 확장자마다 몇 번 나타났나 count 하기
        //1. 정렬 -> 문자의 오름차순 정렬(사전순)
        Arrays.sort(a, 1, N+1);
        //2. 정렬했을때 같으면 카운트 -> i를 증가시키지 않는다. 왜냐하면 다를 때는 j부터 시작해야하므로
        for(int i=1;i<=N;){
            int cnt=1;
            int j=i+1;

            //3. i를 기준으로 같은 경우가 있는지 j로 탐색해서 카운트
            for(;j<=N;j++) {
                //사전순이므로 같은경우엔 모두 붙어있다. -> 다르면 break;
                if (a[j].compareTo(a[i]) == 0) cnt++;
                else break;
            }
            sb.append(a[i]).append(' ').append(cnt).append('\n');

            // 4. a[j] 가 a[i]랑 다를 때는, 다음 i가 j 부터 시작한다.
            i = j;
        }
        System.out.println(sb);
    }
   ```

## 3. 이분 탐색
### 정렬이 되어있지 않은 수열과 탐색 대상 X가 갖는 질문 - O(N)
1. X가 존재하는가
2. X[이하, 이상, 초과]의 원소는 몇개가 있는가
3. X랑 가장 가까운 원소는 무엇인가

### 정렬이 되어 있는 수열과 탐색 대상 X가 갖는 질문 - O(logN)
- 이분 탐색으로 같은 질문을 더 빠르게 해결할 수 있다.

### 이분 탐색 구현을 위한 변수
1. L := 탐색할 가치가 있는 범위의 왼쪽 끝 인덱스
2. R := 탐색할 가치가 있는 범위의 오른쪽 끝 인덱스
3. Result := 탐색한 X의 위치
4. 탐색 목표 := X이하의 원소 중에 가장 오른쪽에 있는 원소
   - L=1, R=9, M=(L+R)/2=5 -> A[M]과 X를 비교
   - L<=R이면 계속 반복, 즉 L>R이면 종료
   - A[M]<X -> L = M+1=6, R=9
   - A[M]>=X -> L=1, R = M-1=4;
   - N이 10만일 때, 10만과 16으로 시간 복잡도의 엄청난 차이가 존재하게 된다.

### 이분 탐색 주의 할점
1. 정렬하지 않는 경우
2. L, R, M, Result를 사용해 부등호를 잘못 사용하는 경우
3. L, R의 범위를 잘못 설정하거나, Result의 초기값을 잘못 설정하는 경우

### 기본 문제
1. 7795번. 먹을 것인가 먹힐 것인가
2. 2470번. 두 용액

### 연습 문제
1. 1920번. 수 찾기
2. 1764번. 듣보잡
3. 3273번. 두 수의 합
4. 10816번. 숫자 카드 2


### 이분 탐색의 아이디어 - 매개변수 탐색
1. 매개변수를 만들기
2. 만든 매개변수로 문제에 해당하는 YES/NO 조건 만들 수 있는가?
3. <span style="color:red">정렬된 상태인지 확인하고 정렬이 필요하면 정렬한다. </span>
4. 바꾼 문제가 더 풀기 쉬우면, 매개변수 탐색 수행해서 해결
   - 정렬하고, 매개변수를 정렬했으니까 왼쪽부터 차례대로 결정하고, 이분탐색한다.
   - O(NlogN), O(N), O(logX) = O(NlogN+NlogX)

### 기본 문제와 해당하는 연습 문제
1. 2805번. 나무 자르기
   1. 1654번. 랜선 자르기
   2. 2512번. 예산
2. 2110번. 공유기 설치
   1. 2343번. 기타 레슨
   2. 6236번. 용돈 관리
   3. 13702번. 이상한 술집 
   4. 17266번. 어두운 굴다리

   
### 연습문제 (Hard)          
1. 1300번. K번째 수
2. 1637번. 날카로운 눈

## 4. 두 포인터
1. 정답을 찾기 위해 찾는 영역(or 과정)을 줄일 수 없을까?
2. 필요한 부분만 (or 빠르게) 탐색
3. 정답을 찾기 위해 탐색해야하는 영역을 줄여서 꼭 필요한 부분만 탐색하도록 하자.

### 투 포인터
- 화살표 두 개에 의미를 부여해서 탐색 범위를 압축한다.
  1. 1차원 배열 위에 2개의 포인터를 만드는 경우
     1. 2개의 포인터가 모두 왼쪽에서 시작해서 **같은 방향**으로 이동
     2. 2개의 포인터가 양 끝에서 **서로를 향해** 이동
  2. 배열로 주어지진 않지만, 관찰을 통해 등장하는 **변수 2개의 값**을 투 포인터로 표현하는 경우

- 투 포인터 키워드
  1. 1차원 배열에서의 "연속 부분 수열" or "순서를 지키며 차례대로"
     - 배열을 모두 보는 게 아니라, 필요한 부분만 압축해서 탐색한다.
  2. 곱의 최소
     - A*B의 최소화를 하기 위해서는, A 커지면, B는 작아져야한다.

- 접근하기
  1. 왼쪽 시작 L을 결정 : O(N)
  2. 오른쪽 끝 R을 L부터 시작해서 이동 : O(N)
  3. O(N^2)
- 넣었다가 뺐다가 -> **++R, R+1, R++**
  1. 왼쪽 시작 L을 결정 : O(N)
  2. 한번만 오른쪽 끝 R을 L부터 시작해서 이동
  3. 커지면 맨 앞부터 빼면서, 작거나 같으면 다음 값부터 추가하면서 탐색한다.

```java
while(R+1<=n&&sum<S){
    R++;
    sum+=a[R];
}

while(R+1<=n&&sum<S){
   sum+=a[++R];
}
```
### 응용 문제 (1) : 두 용액 
#### 이분 탐색을 투포인터로
1. L := "남아 있는 것들 중" 제일 작은 원소
2. R := "남아 있는 것들 중" 제일 큰 원소
#### 현재 남아있는 최솟값+최댓값을 계산을 반복한다.
- 숫자가 하나만 남으면 종료
  1. 최소+최대 <0 -> 최소 입장에서는 최선이므로, 최소를 삭제
  2. 최소+최대 >0 -> 최대 입장에서는 최선이므로, 최대를 삭제
  3. 최소+최대=0 -> 정답이므로 출력
#### 접근법
   1. 매 순간 L,R을 찾는다 -> O(N)
   2. 원소가 1개가 될때까지 반복 -> N번 반복
   3. O(N^2)
#### 정렬과 투포인터로 최솟값과 최댓값을 빠르게 찾는다.
- 정렬된 상태이면, 항상 왼쪽이 최솟값 오른쪽이 최댓값이므로 
- L=R이 되면 서로 다른 용액을 못찾으므로 종료
#### 투포인터를 이용했을 때의 시간 복잡도
1. 정렬 -> O(NlogN)
2. 매순간, L,R로 계산해서 이동시킨다. -> O(N)
3. O(NlogN)

### 응용 문제 (2) : List of Number Unique Numbers
#### 수열에서 연속한 1개 이상의 수를 뽑았을 때 같은 수가 여러 번 등장하지 않은 경우의 수
1. 정답의 최대치 : N이 10만이면 모든 연속 구간이 카운트 ->N+(N-1)...= 50억
   - 따라서 long 타입 사용해야한다.
2. 접근법 (1)
   1. 왼쪽 시작 L 결정 : O(N)
   2. 오른쪽 끝 R을 L부터 시작해서 이동 : O(N)
   3. R을 이동해서 추가된 원소가 [L, R-1] 안에 있는지 확인 : O(N)
      - O(N^3)으로 시간 복잡도를 낮추는 방법 모색해야함
      - 투 포인터를 이용해 꼭 필요한 부분만 탐색하기
3. 접근법 (2)
   1. 왼쪽 시작 L 결정 : O(N)
   2. 오른쪽 끝 R을 L부터 시작해서 이동 : O(N)
   3. 숫자마다 [L, R]안에 몇 개나 있는지 직접 센다.
      - 각 원소가 1부터 10만 사이이므로, 해당 값을 카운팅하는 배열을 만든다.
      - 상수 시간으로 처리가능 : O(1)
   4. O(N^2) -> N이 10만이므로 시간초과
4. 접근법 (3)
   - 1~3까지 중복된게 없다면, 2~3까지도 당연히 중복된게 없다.
     1. R을 이동 가능한 끝까지 이동시키면서 카운팅
     2. 개수를 센다.
     3. L-1을 카운팅에서 제외한다.
   - 정리
     1. 왼쪽 시작 L의 이동 횟수 N번
     2. 오른쪽 끝 R을 이전 R부터 시작해서 이동
     3. L,R이 각자 최대 N번 이동한다. : O(N)
   - 결론
     1. 왼쪽 시작 L 결정 : O(N)
     2. 오른쪽 끝 R을 이전의 R부터 시작해서 이동
     3. R을 이동해서 추가된 원소가 [L, R-1] 안에 있는지 확인 : O(1)
     - O(N) 

### 응용 문제 (3) : 좋다
1. 접근법
   1. 타겟 수 결정 : O(N)
   2. 다른 수 2개 결정해서 만들어지나 확인 : O(N^2)
   3. O(N^3)
2. 투 포인터 적용
   1. 정렬 수행 : O(NlogN)
   2. 타겟 수 결정 : O(N)
   3. 다른 수 2개 결정해서 만들어지나 확인 : O(N)
      - 타겟 숫자와 가까운걸 찾는다.
      - O(N^2)

### 응용 문제 (4) : 고냥이
- 최대 N개의 종류의 알파벳을 가진 연속된 문자열만 인식
- 인식할 수 있는 최대 문자열의 길이? = kind
- 즉, while(kind>N) 반복해서 L을 이동시키면서 조건을 성립하는 최대 문자열의 길이를 찾는다.
- kind를 계산하는 방법
  1. for문으로 돌면서 kind를 O(26)으로 계산하는 방법
  2. kind를 O(1)으로 계산하는 방법
     - 기준 : kind가 바뀌는 기점은 cnt라는 배열에 변화가 발생할 때 
     - 접근 : add, erase 메서드 호출시 cnt라는 배열이 변화한다. 
     - 구현 : add와 erase 메서드 호출했을 때, 
       1. add의 경우, 파라미터에 해당하는 배열 값이 1이 될 때 -> 0에서 1로 변화했을때 kind++ 
       2. erase의 경우, 파라미터에 해당하는 배열 값이 0이 될 때 -> 1에서 0으로 변화했을때 kind--;

## 기본 문제
1. <span style='color:red'> 1806번. 부분합</span>
2. 2470번. 두 용액

## 연습 문제
1. 3273번. 두 수의 합

## 응용 문제
1. 13144번. List of Unique Numbers
2. 1253번. 좋다
   - 2473번. 세 용액
3. 16472번. 고냥이

### 연습 문제
1. 2003번. 수들의 합 2
2. 2559번. 수열
3. 15565번. 귀여운 라이언
4. 11728번. 배열 합치기
5. 2230번. 수 고르기


## 5. 그래프 탐색 (DFS & BFS)
### 인프런
#### 기초 (재귀함수, 트리, 그래프)
 1. 재귀함수 (스택프레임)
 2. 이진수 출력 (재귀 함수)
 3. 팩토리얼
 4. 피보나치 재귀 (메모이제이션)
 5. 이진트리 순회 (DFS)
 6. 부분집합 구하기 (DFS)
 7. 이진트리 레벨탐색 (BFS)
 8. 송아지 찾기1 (BFS)
 9. Tree의 말단 노드까지 가장 짧은 경로 (DFS)
 10. Tree의 말단 노드까지 가장 짧은 경로 (BFS)
 11. 그래프와 인접 행렬
 12. 경로탐색 (DFS)
 13. 경로탐색 (인접리스트)
 14. 그래프 최단 거리 (BFS)
#### 심화


### 백준
1. 기본 구현
   - 1260번. DFS와 BFS
2. 격자형 그래프
   - 2667번. 단지번호 붙이기
   - 1012번. 유기농 배추
   - 11724번. 연결 요소의 개수
   - 4963번. 섬의 개수
   - 3184번. 양
3. 일반 그래프
   - 2606번. 바이러스
   - 11403번. 경로 찾기
   - <span style="color:red"> 11725번. 트리의 부모 찾기 </span>
   - <span style="color:red"> 13023번. N명의 친구 </span>
4. 그래프로 만들기
   - 2251번. 물통
   - 1697번. 숨바꼭질
   - <span style="color:red"> 1389번. 케빈 베이컨의 6단계 법칙 </span>
   - <span style="color:red"> 5567번. 결혼식 
5. 멀터 소스 BFS (시작점이 여러개인 BFS)
   - 14502번. 연구소
   
6. 최소 이동 거리 BFS
   - 2178번. 미로 탐색
   - 7562번. 나이트의 이동
   - 2644번. 촌수 계산
   - 18404번. 현명한 나이트
7. 더블 BFS
   - 3055번. 탈출 (멀티소스 BFS이기도 함)
   - <span style="color:red"> 7569번. 토마토</span>

## 6. 트리
### 키워드
1. 두 정점 사이의 경로가 존재하고, 사이클이 존재하지 않는 경우만 고려한다.
2. 정점과 정점 사이를 잇는 N-1개의 간선이 존재하며, 모든 정점은 연결되어 있다.
3. 정점들이 모두 연결되어 있고, 사이클이 없는 그래프, 정점의 개수는 N이고 간선의 개수는 N-1개

### 아래의 특성 중 2개 이상 만족할 경우 트리
1. 모두가 연결되어 있어서 어떤 두점을 골라도 간선을 타고 서로 이동 가능
2. 사이클이 존재하지 않음
3. 정점 개수 |V| = 간선 개수 |E|+1

### 트리와 루트 트리
1. 트리에는 루트가 존재하는 경우와 루트가 존재하지 않는 경우가 존재
2. 트리가 존재하는 경우, 트리의 깊이를 기준으로 루트로부터의 거리에 대한 조건을 참고해 문제를 푼다.
3. 루트트리에는 조상, 자식, 형제, 말단 노드가 존재한다.
4. 일반적인 알고리즘 문제에서는 루트 트리를 이용한다. 
5. |V|=|E|+1이므로, 인접행렬로 만든다면 |V|의 제곱으로 공간복잡도 낭비

### 백준
1. 구현 (루트가 없는 트리에서 루트 만들기)
   - 11725번. 트리의 부모 찾기
   - <span style="color:red"> 4803번. 트리</span>
2. DFS를 이용하는 동적계획법
   - 1068번. 트리 (단말 노드의 개수(BFS/DFS)로도 가능)
   - 15681번. 트리와 쿼리
   - 14267번. 회사 문화1
3. BFS
   - 1991번. 트리 순회
   - 5639번. 이진 검색 트리
   - 9489번. 사촌
   - 20364번. 부동산 다툼
4. LCA (최소 공통 조상) 
   - 3584번. 가장 가까운 공통 조상
   - 1240번. 노드 사이의 거리
5. 최소신장트리 (크루스칼 알고리즘)
   - 15900번. 나무 탈출 (BFS도 가능)


[//]: # (## 위상정렬)
[//]: # (### )